Эта библиотека обеспечивает интеграцию JaxRS провайдера `CXF` и моделей `Spring Data Common` через автоконфигурацию `Spring Boot`.

= Возможности

* Автоматическое разворачивание REST сервисов (`@Path`)
* Автоматическое подключение REST прокси клиентов
* Интеграция со Swagger (`@Api*`)
* Прозрачная работа с моделями Spring Data: `Page`, `Pageable`, `Sort`
* Обработка и возврат локализованных сообщений об ошибках клиенту в виде json
* Логирование всех запросов / ответов (можно отключить через `jaxrs.log-in=false`, `jaxrs.log-out=false`)
* Включение JSR303 валидаций на REST сервисах (можно отключить через `jaxrs.jsr303=false`)

= Подключение

Для автоматического разворачивания REST сервисов в Spring Boot приложении добавьте зависимость:
[source,xml]
----
<dependency>
  <groupId>net.n2oapp.platform</groupId>
  <artifactId>n2o-platform-starter-jaxrs-server</artifactId>
</dependency>
----

Для подключения REST прокси клиентов добавьте зависимость:
[source,xml]
----
<dependency>
  <groupId>net.n2oapp.platform</groupId>
  <artifactId>n2o-platform-starter-jaxrs-client</artifactId>
</dependency>
----

= Использование

== Сервер

=== Интерфейс и реализация

Чтобы написать REST сервис, создайте интерфейс с аннотациями JaxRs:
[source,java]
----
@Path("/example")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public interface SomeRest {
    ...
}
----

Создайте класс реализующий интерфейс и подключите его к Spring, например, аннотацией `@Controller`:
[source,java]
----
@Controller
public class SomeRestImpl implements SomeRest {
    ...
}
----

=== Паджинация

Чтобы сервисы принимали параметры паджинации и возвращали страницу данных
с общим количеством записей, можно использовать классы Spring Data:
[source,java]
----
@GET
@Path("/search")
Page<SomeModel> search(@BeanParam SomeCriteria criteria);
----

Класс критериев поиска `SomeCriteria` нужен для задания фильтров и должен расширять класс `RestCriteria`,
который в свою очередь является реализацией интерфейса `Pageable`.
[source,java]
----
public class SomeCriteria extends RestCriteria {
    @QueryParam("name")
    private String likeName;
    @QueryParam("date")
    private Date dateBegin;

    //getters setters
}
----

Класс `Page` возвращает список записей одной страницы (`getContent`)
и общее количество записей (`getTotalElements`).

=== Валидации

Чтобы проверить входные данные сервисов на валидность, удобно использовать аннотации JSR303, такие как `@NotNull`, `@Size` и др.
[source,java]
----
@Validated
public class SomeModel {
    private Long id;
    @NotBlank
    private String name;
    @Past
    private Date date;
    //getters setters
}
----


Для того, чтобы активировать аннотации JSR303, необходимо пометить аргументы REST метода аннотацией `@Valid`:
[source,java]
----
@POST
@Path("/")
Long create(@Valid SomeModel model);
----

Если валидации не используются, обработчика валидаций можно отключить настройкой `jaxrs.jsr303=false`.

=== Исключения и локализация

Все исключения возвращаются клиенту в виде json:

[source,json]
----
{
  "message" : "Some error",
  "stackTrace":[
    "...",
    "\tat ...",
    "\tat ...",
    "\tat ...",
    "\tat ..."
  ]
}
----
В поле `message` попадает сообщение исключения, в поле `stackTrace` весь список строк java стектрейса.

Чтобы локализовать сообщение для клиента, выбрасывайте специальное исключение `UserException`:
[source,java]
----
throw new UserException("example.code")
            .set("раз")
            .set("два");
----
Подробнее о нем написано в модуле `n2o-platform-i18n`.

Чтобы передать сообщение под каждое поле формы используйте JSR303 валидации.
В этом случае в json ответ добавится поле `errors`:

[source,json]
----
{
  "errors" : [
    {
      "field" : "create.arg0.name",
      "message" : "не может быть пусто"
    }
  ]
}
----
А http статус будет `400`.

=== Логирование

Все запросы и ответы, и сервера, и клиента логгируются по умолчанию. Их можно отключить настройкой `jaxrs.log-in=false`, `jaxrs.log-out=false`.

=== Документирование

Используйте на рест сервисах аннотации `@Api*` из пакета `io.swagger.annotations`.
[source,java]
----
@Path("/example")
@Api("Пример документирования REST сервиса")
public interface SomeRest {
    @GET
    @Path("/search")
    @ApiOperation("Найти что-нибудь")
    @ApiResponse(code = 200, message = "Нашли что-то")
    Page<SomeModel> search(@BeanParam SomeCriteria criteria);
    ...
}
----

В настройках приложения задайте путь к REST сервисам со swagger аннотациями и другие параметры:
[source,python]
----
jaxrs.swagger.enabled=true
jaxrs.swagger.title=REST сервисы для примера
jaxrs.swagger.version=1.0
jaxrs.swagger.resource-package=net.n2oapp.microservice.example
----

Ссылка на документацию Swagger будет доступна по адресу `/api/info`.

image::images\README-f585f.png[]

== Прокси клиент

=== Поиск JaxRs интерфейсов

Чтобы подключить REST прокси клиент, как обычный Spring бин, задайте следующие настройки:
[source,python]
----
#Включение поиска и регистрации прокси клиентов
cxf.jaxrs.client.classes-scan=true
#Пакет, в котором искать JaxRs интерфейсы
cxf.jaxrs.client.classes-scan-packages=net.n2oapp.microservice.example
#Адрес, где развернуты REST сервисы
cxf.jaxrs.client.address=http://localhost:8080/api
----

В этом случае сработает автоконфигурация `JaxRsClientAutoConfiguration` и создадутся прокси клиенты под каждый найденный интерфейс.

=== Выборочное подключение

Если вам требуются сервисы развернутые на разных адресах, то нужно использовать более тонкий способ настройки с помощью аннотации `@EnableJaxRsProxyClient`:
[source,java]
----
import net.n2oapp.platform.jaxrs.autoconfigure.EnableJaxRsProxyClient;
...
@Configuration
@EnableJaxRsProxyClient(
  classes = SomeRest.class,
  address = "${myapp.url}/example/api")
public class ExampleConfiguration {
  ...
}
----


=== Использование

Используйте REST прокси клиенты как обычные Spring бины:
[source,java]
----
@Service
public class ConsumerServiceImpl {
  @Autowired
  private SomeRest client;//REST прокси клиент

  ...
}
----
Каждый вызов метода прокси клиента будет делать http запрос к сервису.

=== Обработка исключений

При использовании REST прокси клиентов, исключения возникшие на сервере,
автоматически выбрасываются и на клиенте. Класс исключений: `RestException`:
[source,java]
----
try {
   client.create(model);
 } catch (RestException e) {
   e.getMessage();//Локализованное сообщение
   e.getErrors();//Ошибки JSR303 валидаций
 }
----
При этом стектрейс исключения `RestException` будет содержать в себе стектрейс от сервера.

== Веб клиент

=== Инициализация

Для подключения WEB клиента, необходимо на класс конфигурации Spring повесить аннотацию `@EnableJaxRsWebClient`:
[source,java]
----
@Configuration
@EnableJaxRsWebClient
public class ExampleConfiguration {
  ...
}
----

Адрес REST сервисов задаётся настройкой:
[source,python]
----
cxf.jaxrs.client.address=http://localhost:8080/api
----

=== Использование

Для выполнения запросов к REST сервисам, через аннотацию `@Autowired` подключаем клиента:
[source,java]
----
@Service
public class ConsumerServiceImpl {
  @Autowired
  private Client client;

  ...
}
----


=== Формат даты и времени
В качестве формата даты и времени в параметрах запроса, в теле запроса и ответа
используется формат *ISO8601*:
----
YYYY-MM-DDThh:mm:ss[.sss]
----
